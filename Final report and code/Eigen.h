#include <fstream>
#include <sstream>

class Eigen : public Classifier
{
public:
    CImg<double>  eigen_matrix;
    Eigen(const vector<string> &_class_list) : Classifier(_class_list) {}

    virtual void train(const Dataset &filenames)
    {
      // Create input file for SVM multiclass
        save_train_features(filenames, true);
        system(("./svm_multiclass/svm_multiclass_learn -c 100 " + train_filename).c_str());
    }

    // Classify a single image during testing.
    virtual string classify(const string &filename)
    {
        int pred;
        string line;

        // Create input file for SVM multiclass
        save_test_features(filename, true);
        system(("./svm_multiclass/svm_multiclass_classify " + test_filename + " svm_struct_model > /dev/null").c_str());

        // Load prediction
        ifstream in("svm_predictions");

        if (!in.is_open())
        {
            cerr << "Cannot open svm_predictions";
            return "";
        }

        // Read prediction class
        in >> pred >> line;

        return classes[pred-1];
    }

    // Loading the trained model.
    virtual void load_model()
    {
        string classname;
        ifstream in(classes_filename);

        if (!in.is_open())
        {
            cerr << "Cannot open " << classes_filename;
            return;
        }

        // Load a list of classes that used during training
        while (in >> classname)
            classes.push_back(classname);

        // loading Eigen matrix    
        string matrix_row;
        ifstream input(eigen_filename);
        CImg<double> some_matrix((size * size), k);

        if(!input.is_open()){
            cerr << "Cannot open " << eigen_filename;
            return;
        }
        int row_val =0 ;
        int col_val = 0; 
        while(input >> matrix_row){
            if(col_val == (size * size)){
                col_val = 0;
                row_val += 1;
            }
            some_matrix(col_val, row_val) = stod(matrix_row);
            col_val += 1;
        }
        eigen_matrix = some_matrix;
        // displaying the eigen_matrx
           for(int i=0; i < eigen_matrix.width(); i++){
          for(int j =0; j < eigen_matrix.height() ; j++){
            cout << eigen_matrix(i,j) << "\t" ;
          }
          cout << "\n" << "\n" << endl;
          }
    }
    
protected:
    const int size = 50;
    const string classes_filename = "eigen_classes.dat";
    const string train_filename = "eigen_train.dat";
    const string test_filename = "eigen_test.dat";
    const string eigen_filename = "eigen_mat.dat";
    vector<string> classes;
    const int k = 500;
    const int total_training_images = 1250;

    // Returns the resized, vector form of each image in training
    CImg<double> extract_features_training(const string &filename, const bool greyscale=true)
    {
        CImg<double> input_image(filename.c_str());
        stringstream features;

         // Convert image to grayscale
        if (greyscale && input_image.spectrum() == 3)
            input_image.RGBtoHSI().channel(2);

         // Resize image
        if (greyscale)
            input_image.resize(size, size, 1, 1).unroll('y');
        else
            input_image.resize(size, size, 1, 3).unroll('y');

        return input_image;
    }


    string extract_features(const string &filename, const bool greyscale=true)
    {
        CImg<double> input_image(filename.c_str());
        stringstream features;

            // Convert image to grayscale
        if (greyscale && input_image.spectrum() == 3)
            input_image.RGBtoHSI().channel(2);

            // Resize image
        if (greyscale)
            input_image.resize(size, size, 1, 1).unroll('y');
        else
            input_image.resize(size, size, 1, 3).unroll('y');

        // generating features for svm
        CImg<double> output_mat = this->eigen_matrix * input_image;
        CImg<double> final_mat = transpose(output_mat);

        for(int i =0; i < final_mat.width(); i++){
            features << i+1 << ":" << final_mat(i, 0) << " ";
        }


        return features.str();
    }

    // Writes the eigen_matrix generated by the training functions.
    void input_model(CImg<double> eig_mat){
        ofstream out_mat(eigen_filename);

        if (!out_mat.is_open())
        {
            out_mat.close();
            cerr << "Cannot open " << eigen_filename;
            return;
        }

        for(int i =0; i < eig_mat.height(); i++){
            for(int j =0; j < eig_mat.width() ; j++){
                out_mat << eig_mat(j, i) << "\t";
            }
            out_mat << endl;
        }

        out_mat.close();
    }


    void save_train_features(const Dataset &filenames, const bool greyscale=true)
    {
        int c = 1;

        CImg<double> training_vector(total_training_images, size*size);

        int val = 0;
        for (Dataset::const_iterator c_iter = filenames.begin(); c_iter != filenames.end(); ++c_iter)
        {
            cout << "Processing " << c_iter->first << endl;

            for (int i = 0; i < c_iter->second.size(); ++i)
            {
                    // Write training data to file
                CImg<double> features = extract_features_training(c_iter->second[i].c_str(), greyscale);

                for(int index=0; index < features.height(); index++){
                    training_vector(val, index) = features(0, index);
                }

                val += 1;
            }
                // Move to the next class
            c++;
        }
        eigen_matrix = eigen_decomposition(training_vector);
        input_model(eigen_matrix);
        generating_features_svm(filenames, true);
    }

    // This function generates the eigen features for each training image which is fed as input to the svm classifier.
    void generating_features_svm(const Dataset &filenames, const bool greyscale = true){
        ofstream out(train_filename);
        ofstream classes(classes_filename);
        int c = 1;

        if (!out.is_open()){
            cerr << "Cannot open " << endl;
            return;
        }

        if (!classes.is_open())
        {
            out.close();
            cerr << "Cannot open " << classes_filename;
            return;
        }

        for (Dataset::const_iterator c_iter = filenames.begin(); c_iter != filenames.end(); ++c_iter)
        {
            cout << "Processing " << c_iter->first << endl;
            classes << c_iter->first << endl;

            for (int i = 0; i < c_iter->second.size(); ++i)
            {
          // Write training data to file                                                                                     
                string features = extract_features(c_iter->second[i].c_str(), greyscale);
                out << c << " " << features << endl;
            }

          // Move to the next class                                                                                              
            c++;
        }

        out.close();
        classes.close();
    }


    void save_test_features(const string &filename, const bool greyscale=true)
    {
        ofstream out(test_filename);

        if (!out.is_open())
        {
            cerr << "Cannot open " << test_filename;
            return;
        }

        string features = extract_features(filename, greyscale);
        out << "1 " << features << endl;
        out.close();
    }

    // returns the mean of a particular row, in the input matrix.
    double entire_row(CImg<double> input_matrix, int row_num){
        double output_matrix;
        for(int i =0; i < input_matrix.width(); i++){
            output_matrix += input_matrix(i, row_num);
	}
        output_matrix = (output_matrix/input_matrix.width());
	return output_matrix;
    }
    

    CImg<double> eigen_decomposition(CImg<double> image_concat){
        // calculating the mean food for each class     
        CImg<double> mean_food(1, image_concat.height());
        for(int r =0; r < image_concat.height(); r++){
            mean_food[0, r] = entire_row(image_concat, r);
        }
        // centering the image data                                                                                              
        for(int b = 0; b< image_concat.width(); b++){
            for(int d = 0; d < image_concat.height(); d++){
                 image_concat(b, d) = image_concat(b, d) - mean_food(0, d);
            }
        } 
        // eigen decomposition performed
        CImg<double> covariance_matrix(image_concat.height(), image_concat.height()); 
        covariance_matrix = (image_concat * transpose(image_concat))/(image_concat.width());
        CImgList<double> eigen_decomp = covariance_matrix.get_symmetric_eigen();
        cout << "Eigen decomp done " << endl;
       
        /*for(int i =0; i < eigen_decomp[0].height(); i++){
            cout << eigen_decomp[0](0, i) << endl;
            }*/
        // selecting k eigen values and corresponsing eigen vectors
        CImg<double> reduced_features(eigen_decomp[1].width(),k);
        for(int row =0; row < k; row++){
            for(int col = 0; col < eigen_decomp[1].width(); col++){
                reduced_features(col, row) = eigen_decomp[1](col, row);
                cout << reduced_features(col, row) << "\t";
            }
            cout << "\n" << "\n" << endl;
        }
        return reduced_features;   
    }  
};
